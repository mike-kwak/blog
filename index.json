[{"categories":["java","spring"],"contents":"스프링 내에선 RestTemplate란 객체가 존재해 HTTP 요청을 쉽게 할 수 있다. 하지만 RestTemplate를 요청 시 생성해서 사용하거나 하는 잘못된 방법이 존재한다. RestTemplate 내 HTTP Client 종류와 설명, Bean 등록 설정까지 해보고, RequestEntity 객체를 통해 코드 가독성 좋게 요청하는 방법과 번외로 URI를 템플릿화 하여 작성할 수 있는 UriComponentsBuilder 클래스 사용법까지 작성해 보았다.\n   RestTemplate 클래스 및 사용용도   Spring RestTemplate JavaDoc (Spring Framework 3.0 이상)  HTTP 요청 시 사용하는 클래스이다. 객체를 생성하고 메소드를 살펴보면 많은 메소드들이 펼쳐져 있다. 각각의 HTTP Method마다 존재하고 매개변수에 따라 여러 메소드들을 골라 사용할 수 있다. 하지만 HTTP Method와 URL만 해도 간단하지 않다. 따라서 아래의 메소드를 사용하는 것을 권장한다.\n  exchange(RequestEntity\u0026lt;?\u0026gt; entity, Class\u0026lt;T\u0026gt; responseType)\n  exchange(RequestEntity\u0026lt;?\u0026gt; entity, ParameterizedTypeReference\u0026lt;T\u0026gt; responseType)\n  이 두개의 메소드의 차이는 뒤의 타입 정보 전달의 차이가 존재한다. 첫번째 Class타입은 평상시에 사용하면 되지만, 만약 제네릭 타입을 받아야 할때는 두번째 메소드를 사용할 수 있다. 자세한 사용 방법은 아래 RestTemplate 잘 사용하기에서 살펴보겠다.\n이 RestTemplate를 그냥 new로 생성 했을 땐 자바에 내장된 HttpUrlConnection 클래스를 사용한다. JDK 1.1부터 사용되었고, 버전업하며 크게 개선된 건 없어 단순히 연결 후 요청하고 응답하는 액션만 처리할 뿐이다. 커넥션 방법인 Connection: keep-alive나 HTTP/2와 같은 프로토콜에서의 속도 개선사항을 적용받을 수 없다.\n   HTTP Client 라이브러리를 RestTemplate에 등록 및 Bean 설정  우리는 두가지 라이브러리 중 하나를 선택해 도움을 받을 수 있다.\n  OkHttp\n  HTTP/2 지원.\n  Android에서 HTTP 요청 시 사용하는 라이브러리인 Retrofit이 사용하는 라이브러리.\n  코틀린 코드로 작성되어 코틀린 라이브러리가 의존성에 포함.\n    Apache HttpComponents\n  자바로 작성됨.\n  오랫동안 검증된 Apache Commons에서 분리한 프로젝트.\n  버전 4는 HTTP/1.1까지 지원.\n    라이브러리를 선택했다면 Spring Boot 2.x 기준으로 설정 방법을 설명하겠다.\n   OkHttp 라이브러리 설정 방법    Maven Central 검색 사이트\n  아래 코드를 바로 입력하기 보다, Maven 검색 사이트에서 최신 버전을 살펴보고 제공하는 코드를 입력하는 것을 권장한다.\n  현재 OkHttp 5 alpha 버전이 등록되고 있지만 호환성을 담보하지 않으므로 최신의 4.x.x 버전을 사용 권장한다.\n    Maven\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.9.2\u0026lt;!-- 2021/10 기준 최신버전 --\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     Gradle\n1  implementation \u0026#39;com.squareup.okhttp3:okhttp:4.9.2\u0026#39;        Apache HttpComponents 라이브러리 설정 방법    주의! HttpComponents 5 이상 버전은 Spring Framework 5.3 에서 사전 설정이 존재하지 않음!\n 만약 직접 사용 시엔 ClientHttpRequestFactory 인터페이스를 이용해 클래스 구현.    Maven Central 검색 사이트\n 아래 코드를 바로 입력하기 보다, Maven 검색 사이트에서 최신 버전을 살펴보고 제공하는 코드를 입력하는 것을 권장한다.    Maven\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.13\u0026lt;!-- 2021/10 기준 최신버전 --\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     Gradle\n1  implementation \u0026#39;org.apache.httpcomponents:httpclient:4.5.13\u0026#39;        HttpClientConfiguration 설정 코드  위 OkHttp와 HttpComponents 라이브러리 설정 시에 Spring Boot에서 제공하는 클래스가 있다. RestTemplateBuilder 클래스이다.\n Spring Boot RestTemplateBuilder JavaDoc  이 클래스는 이미 Spring Boot를 사용 하고 있다면, RestTemplateAutoConfiguration에 의해 Bean으로 설정되어있다. 이미 설정된 MessageConverter가 포함된 상태이므로 RestTemplateBuilder Bean을 받아 build() 메소드로 RestTemplate 클래스를 생성하여 Bean으로 등록하면 된다.\n  OkHttp 사용 시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import okhttp3.OkHttpClient; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.OkHttp3ClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; @Configuration public class HttpClientConfiguration { @Bean public RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) { return restTemplateBuilder .requestFactory(() -\u0026gt; new OkHttp3ClientHttpRequestFactory(new OkHttpClient())) .build(); } }     Apache HttpComponents 4 사용 시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import org.apache.http.client.HttpClient; import org.apache.http.impl.client.HttpClients; import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; @Configuration public class HttpClientConfiguration { @Bean public RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) { return restTemplateBuilder .requestFactory(() -\u0026gt; new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault())) .build(); } }     만약, Spring Boot 기반이 아닌 구 버전 사용자는 RestTemplate를 new로 생성 후 등록할 수도 있다.\n  OkHttp 사용 시 (Spring Framework 4.3 이상)\n1 2 3 4 5 6 7 8 9 10 11 12  import okhttp3.OkHttpClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.OkHttp3ClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; ... @Bean public RestTemplate restTemplate() { return new RestTemplate(new OkHttp3ClientHttpRequestFactory(new OkHttpClient())); }     Apache HttpComponents 4 사용 시 (Spring Framework 4.0 이상 권장)\n1 2 3 4 5 6 7 8 9 10 11 12 13  import org.apache.http.client.HttpClient; import org.apache.http.impl.client.HttpClients; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; ... @Bean public RestTemplate restTemplate() { return new RestTemplate(new HttpComponentsClientHttpRequestFactory(HttpClients.createDefault()); }        Interceptor 구현 및 등록  RestTemplate을 통해 요청 전, 후로 어떠한 작업을 하고 싶다면, ClientHttpRequestInterceptor 인터페이스를 구현해 붙이면 된다. 특히 반복적으로 인증 헤더를 붙인다던지, 요청 로그를 찍을 때 유용하다.\n ClientHttpRequestInterceptor JavaDoc  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  ... import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; import org.springframework.util.StreamUtils; import java.nio.charset.StandardCharsets; ... private static final Logger log = LoggerFactory.getLogger(HttpClientConfiguration.class); @Bean public RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) { return restTemplateBuilder .requestFactory(() -\u0026gt; new OkHttp3ClientHttpRequestFactory(new OkHttpClient())) .interceptors(loggingInterceptor()) .build(); } private ClientHttpRequestInterceptor loggingInterceptor() { return (req, reqBody, execution) -\u0026gt; { // HTTP Request 로그  if (log.isDebugEnabled()) { log.debug(\u0026#34;req {} {}, body: {}\u0026#34;, req.getMethodValue(), req.getURI(), new String(reqBody, StandardCharsets.UTF_8)); } // HTTP 요청 실행  ClientHttpResponse res = execution.execute(req, reqBody); // HTTP Response 로그  if (log.isDebugEnabled()) { log.debug(\u0026#34;res {}, body: {}\u0026#34;, res.getRawStatusCode(), StreamUtils.copyToString(res.getBody(), StandardCharsets.UTF_8)); } return res; }; }   위와 같은 코드로 인터페이스 내에 메소드는 하나이기 때문에, 람다로 구현할 수 있다. 그리고 RestTemplate Bean 생성 시에 인터셉터를 삽입해줄 수 있다.\n문제는 ClientHttpRequestInterceptor 내 응답 InputStream을 현재 상태에서 구현 후 사용 시 인터셉터 내에서는 데이터가 존재하지만, 실제로 RestTemplate 객체를 사용한 곳에 리턴 값이 존재하지 않아 예외가 던저지거나 객체 내 값들이 null일 수 있다. 그 이유는 인터셉터 내의 InputStream이 한번 사용하면 스트림이 소모되어 다시 사용할 수 없게 되기 때문이다.\n그래서 필요한 것이 BufferingClientHttpRequestFactory 클래스이다. 이 클래스는 Buffering이 붙은 만큼 InputStream을 사용해도 사라지지 않는다.\n BufferingClientHttpRequestFactory JavaDoc  이 클래스의 생성자는 간단하게 우리가 실제 사용할 ClientHttpRequestFactory 객체를 한번 감싸주면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12  ... import org.springframework.http.client.BufferingClientHttpRequestFactory; ... @Bean public RestTemplate restTemplate(RestTemplateBuilder restTemplateBuilder) { return restTemplateBuilder .requestFactory(() -\u0026gt; new BufferingClientHttpRequestFactory( new OkHttp3ClientHttpRequestFactory(new OkHttpClient()) )) .build(); }      RestTemplate 잘 사용하기  먼저 RestTemplate 사용 시엔 new로 생성하는 것보다, 위에서 Bean 등록한 객체를 Autowired 또는 생성자로 필드 선언하여 Bean 객체를 의존 주입으로 받아 사용하는 것이 좋다.\n1 2  @Autowired private RestTemplate restTemplate;   위에서 두 exchange 메소드를 언급했었다.\n  exchange(RequestEntity\u0026lt;?\u0026gt; entity, Class\u0026lt;T\u0026gt; responseType)\n  exchange(RequestEntity\u0026lt;?\u0026gt; entity, ParameterizedTypeReference\u0026lt;T\u0026gt; responseType)\n  이 메소드를 이용해 HTTP 요청을 보내고 받는 코드 예제를 보여줄 것이다. 이 두 메소드의 차이는 리턴 타입을 받는 형태의 차이이다. 위의 클래스 타입을 매개변수로 받는 메소드는 간단한 String.class, byte[].class, 제네릭 클래스가 아닌 모든 클래스 타입에 사용할 수 있다.\n만약 Map, List나 기타 컬렉션류, 제네릭 클래스일 경우엔 아래의 ParameterizedTypeReference 클래스를 객체로 생성하여 타입을 받을 수 있다. 여기서 ParameterizedTypeReference\u0026lt;T\u0026gt; 생성자는 protected이지만 익명 객체로 아무런 구현 없이 아래와 같이 생성할 수 있다.\n1  new ParameterizedTypeReference\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;() {}    Spring RequestEntity JavaDoc (Spring Framework 4.1 이상)  메소드에서 매개변수로 받는 RequestEntity는 HttpEntity의 자식 클래스로, 다용도로 사용 할 수 있다. 특히 컨트롤러에서 다음과 같이 매개변수로 선언 시 요청 데이터들을 사용할 수 있다.\n1 2 3 4  @PostMapping(\u0026#34;/post\u0026#34;) public void post(RequestEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; request) { ... }   여기서는 RestTemplate의 요청 객체로 선언하여 사용할 수 있다. 아래는 간단한 예제이다.\n1 2 3 4 5 6 7 8 9 10 11  import org.springframework.core.ParameterizedTypeReference; import org.springframework.http.RequestEntity; import java.net.URI; ... private Map\u0026lt;String, Object\u0026gt; request() { RequestEntity\u0026lt;Void\u0026gt; request = RequestEntity.get(URI.create(\u0026#34;https://httpbin.org/anything\u0026#34;)).build(); return restTemplate.exchange(request, new ParameterizedTypeReference\u0026lt;\u0026gt;() {}).getBody(); }   조금 더 복잡한 예제인 아래와 같은 형태의 JSON 문서를 POST 요청 하는 것을 해보자.\n1 2 3 4 5 6  { \u0026#34;send_id\u0026#34;: 1, \u0026#34;message\u0026#34;: \u0026#34;Hello, Mike!\u0026#34;, \u0026#34;receiver\u0026#34;: [\u0026#34;mike\u0026#34;, \u0026#34;anonymous\u0026#34;], \u0026#34;is_beep\u0026#34;: true }   이러한 JSON 객체를 요청하고 응답하는 메소드는 다음과 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  import org.springframework.core.ParameterizedTypeReference; import org.springframework.http.RequestEntity; import java.net.URI; import java.util.Arrays; import java.util.Map; import java.util.HashMap; ... private Map\u0026lt;String, Object\u0026gt; request() { Map\u0026lt;String, Object\u0026gt; requestBodyMap = new HashMap\u0026lt;\u0026gt;(); requestBodyMap.put(\u0026#34;send_id\u0026#34;, 1); requestBodyMap.put(\u0026#34;message\u0026#34;, \u0026#34;Hello, Mike!\u0026#34;); requestBodyMap.put(\u0026#34;receiver\u0026#34;, Arrays.asList(\u0026#34;mike\u0026#34;, \u0026#34;anonymous\u0026#34;)); requestBodyMap.put(\u0026#34;is_beep\u0026#34;, true); RequestEntity\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; request = RequestEntity.post(URI.create(\u0026#34;https://httpbin.org/anything\u0026#34;)) .body(requestBodyMap); return restTemplate.exchange(request, new ParameterizedTypeReference\u0026lt;\u0026gt;() {}).getBody(); }   간단한 형태는 Map\u0026lt;String, Object\u0026gt; 타입으로 주고 받을 수 있고, 복잡한 형태는 Value Object 클래스를 만들어 사용할 수도 있다.\n   Exception  RestTemplate 객체를 사용해서 HTTP 요청 후 응답 상태가 만약 4XX를 받게 된다면, HttpClientErrorException 예외를 던진다. 5XX일 경우엔 HttpServerErrorException 예외를 던진다. 이 두 예외 클래스는 HttpStatusCodeException의 자식 클래스이다. 사실 이 예외 클래스들은 계층 관계가 복잡한데, 여러가지 예외 형태를 묶다보니 생긴 일인 듯 하다.\n또한 RestTemplate 사용 중 발생하는 예외는 RestClientException의 하위 클래스이다.\n  RestClientException (Spring 3.0 이상)\n 모든 RestTemplate의 Exception 처리를 담당한다. HTTP 응답 에러 뿐만 아니라 I/O 에러, JSON 이나 XML 포멧 등을 처리 하기 위한 MessageConverter 작동 중 에러 등 모두를 포함한다.    RestClientResponseException (Spring 4.3 이상)\n HTTP 응답 에러를 위한 예외 클래스이다. 모든 응답 상태를 잡으려면 이 예외 발생 객체를 처리하면 된다.    UnknownHttpStatusCodeException (Spring 4.2 이상)\n HTTP 응답 에러 중 표준이 아닌 알 수 없는 응답 상태에 대한 예외 처리를 위한 클래스이다.    HttpStatusCodeException (Spring 3.0 이상)\n HTTP 응답 에러 중 알려진 응답 상태에 대한 예외 처리를 위한 클래스이다.    HttpClientErrorException (Spring 3.0 이상)\n HTTP 4XX Client Error 응답 시에 던져지는 예외 클래스이다.    HttpServerErrorException (Spring 3.0 이상)\n HTTP 5XX Server Error 응답 시에 던져지는 예외 클래스이다.    위와 같은 예외 클래스 계층이 존재하며, 필요한 목적에 따라 사용할 수 있다. 보통은 RestClientResponseException 타입만 catch해서 사용하면 응답하는 모든 상태에 대한 처리를 할 수 있다.\n   번외, UriComponentBuilder  URI.create(String uri) 정적 생성 메소드는 문자열로 간단하게 URI 객체를 생성할 수 있지만 매개변수 문자열이 잘못된 형식일 때 URISyntaxException 예외가 던져지는 위험이 존재하고, URI 형태가 비슷하면서 어떠한 경로나 쿼리 변수만 다르게 템플릿화 시키고 싶다면 문자열로 직접 사용하는 것은 하드코딩이 될 수 있다.\n그래서 안전하고 템플릿 형태로 만들 수 있는 UriComponentsBuilder 클래스와 UriComponents 클래스 두개의 사용법을 간단히 소개한다.\n Spring UriComponentsBuilder JavaDoc Spring UriComponents JavaDoc JDK java.net.URI JavaDoc  UriComponentsBuilder 클래스는 new 생성자가 아닌, 정적 생성 메서드가 몇가지 존재한다.\n  fromHttpUrl(String httpUrl)\n 일반적으로 사용하는 주소창의 URL을 문자열로 받는다. https://www.google.com/search?q=resttemplate 과 같은 형태.    fromPath(String path)\n 프로토콜이나 도메인이 빠진 경로 형태의 문자열을 받을 수 있다. /auth/tokens 와 같은 형태 {variable}과 같이 템플릿을 위한 변수 설정도 가능하다.    fromUri(URI uri)\n java.net.URI 객체를 받는 형태    fromUriString(String uri)\n URI의 문자열 형태를 받을 수 있다. URI는 웹 주소 뿐만 아니라 tel:+82-2-0000-0000, mailto:someone@example.com?subject=hello 같은 형태도 가능.    newInstance()\n 아무런 매개변수 없이 일단 객체를 생성한다.    기타 다른 메소드는 JavaDoc 참조\n  정적 생성 메서드를 매개로 Builder 패턴으로 필요한 것을 붙여가며 객체 생성이 가능하다. 주요 빌더 메서드들은 다음과 같다.\n  scheme(String scheme), host(String host), port(int port)\n scheme는 http, https, ftp와 같은 프로토콜이 될 수 있다. 또는 tel, mailto와 같은 정보 단위일 수 있다. host는 google.com, youtube.com, 127.0.0.1과 같은 ip나 hostname 이다. port는 프로토콜 통신 시 HTTP 80, HTTPS 443과 같은 기본 포트가 아닐 시 지정한다.    path(String path), pathSegment(String... pathSegments)\n path는 /부터 시작하며 /v3/auth/tokens와 같은 위치를 나타낸다. pathSegment는 경로의 조각이며 auth/token과 같은 조각을 뜻한다.    replacePath(String path)\n replacePath는 이미 지정한 경로를 지우고 새로 지정하는 것이다.    queryParam(String name, Object... values), queryParam(String name, Collection\u0026lt;?\u0026gt; values)\n queryParam은 ? 뒤의 매개변수를 지정하는 것이며, URI에서 ?query=http\u0026amp;page=2와 같은 형태다. values 뒤에 여러 개의 객체 또는 객체 컬렉션을 지정할 수 있으며, ?query=first\u0026amp;query=second와 같이 붙는다.    queryParams(MultiValueMap\u0026lt;String, String\u0026gt; params)\n MultiValueMap으로 위의 파라메터를 한꺼번에 지정할 수 있으며, 사용 시엔 구현체인 LinkedMultiValueMap 클래스를 객체로 생성하여 사용한다.    uri(URI uri), uriComponents(UriComponents uriComponents)\n URI 객체나 UriComponents 객체를 합칠 수 있다.    UriComponents build(), UriComponents buildAndExpand(Object... uriVariableValues)\n 모두 다 조합 후 build 메소드를 통해 UriComponents 객체를 생성한다. 만약 Path 내 {variable}과 같은 템플릿 변수가 있다면 buildAndExpand를 통해 앞에서부터 순서대로 문자열이나 toString이 가능한 객체를 삽입시킨다.    기타 다른 메소드는 JavaDoc 참조\n  만약 UriComponentsBuilder 객체를 통해 UriComponents 객체를 생성했다면, toUri() 메소드를 통해 우리가 사용하기 위한 실제 java.net.URI 객체를 생성하여 사용할 수 있다.\n1 2 3 4 5  UriComponents hostUriComponents = UriComponentsBuilder.fromHttpUrl(\u0026#34;https://www.example.com\u0026#34;).build(); URI uri = UriComponentsBuilder.fromPath(\u0026#34;/test/{testNumber}\u0026#34;) .uriComponents(hostUriComponents) .queryParam(\u0026#34;query\u0026#34;, \u0026#34;hello\u0026#34;) .buildAndExpand(\u0026#34;1\u0026#34;).toUri();   URI 구조가 복잡하거나, 코드 분기에 따라 URI 형태가 바뀌어야 한다면 UriComponentsBuilder 클래스를 잘 사용하면 쉽게 URI 객체를 생성할 수 있다.\n   마치며  스프링은 HTTP 요청 시에 Spring WebFlux 내 WebClient 클래스를 사용하는 것을 Spring Framework 5 부턴 권장하고 있다. 하지만 서블릿 기반으로 개발한 코드 위에 WebClient 하나 만을 위해 라이브러리 의존성 추가 하는 것도 이상하다. 또한 Project Reactor 라이브러리의 비동기 코드를 이해해야 사용하기 수월하다.\n따라서 아직도 서블릿 기반 코드에서는 RestTemplate 클래스가 자주 사용하게 된다. 하지만 부적절하게 사용되는 케이스를 많이 보았었다. 이 글이 RestTemplate 클래스를 잘 사용할 수 있게 도와주는 가이드 역할이 되었으면 한다.\n","date":"Oct 28","permalink":"https://hellomike.page/posts/2021/spring-rest-template-and-request-entity-and-uri/","tags":["java","spring","utils","restful","http","rest-template","okhttp","httpcomponents","uri"],"title":"스프링 RestTemplate 잘 활용하기"},{"categories":["java","spring"],"contents":"스프링에는 유용한 도구들이 많이 준비되어있다. 하지만 주변에서는 그런 존재를 몰라 라이브러리를 따로 사용하는 경우가 많았다. 이 글에서는 스프링 프레임워크의 StreamUtils, Resource 인터페이스와 그 구현체 클래스를 활용하는 팁들을 작성했다.\n   StreamUtils 유틸 클래스   Spring Framework StreamUtils JavaDoc Spring Framwork 3.2.2 부터 사용 가능  이 유틸 클래스는 스프링 프레임워크 내에 내장되어 있고, Java Input/Output Stream을 다루기 위한 것이다. 실제로 자바에서 Input/Output Stream 다루기엔 보일러플레이트(사전 준비) 코드들이 많다.\n아래는 InputStream을 String으로 바꾸는 코드이다.\n 코드 출처 : How do I read / convert an InputStream into a String in Java? - Stack Overflow  1 2 3 4 5 6 7 8 9 10 11 12  // 가장 빠르다던 ByteArrayOutputStream 이용: https://stackoverflow.com/a/35446009 public String streamToString(InputStream inputStream) throws IOException { ByteArrayOutputStream result = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; for (int length; (length = inputStream.read(buffer)) != -1; ) { result.write(buffer, 0, length); } // JDK 1.7 미만 사용 시 \u0026#34;UTF-8\u0026#34;로 대체  return result.toString(StandardCharsets.UTF_8.name()); } ... String str = streamToString(inputStream);   물론 위 코드를 유틸클래스를 만들어서 구현하는 방법도 괜찮다. Java 내에선 가장 빠른 코드이기 때문이다. 하지만 저 코드가 생각나지 않을 때는 어떻게 할까? 아니면 String이 아니라 다른 형태로 받고 싶다면? commons-io 라이브러리의 IOUtils 유틸 클래스와 비슷하게, 스프링 프레임워크는 이미 StreamUtils 유틸 클래스를 준비해두었다.\n1 2 3 4  import org.springframework.util.StreamUtils; import java.nio.charset.StandardCharsets; ... String str = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);      자주 쓰는 메소드    static byte[] copyToByteArray(InputStream in)\n InputStream을 byte 배열로 반환한다.    static String copyToString(InputStream in, Charset charset)\n InputStream을 문자열로 반환한다.    static InputStream emptyInput()\n 빈 InputStream을 반환한다.    1번인 InputStream을 Byte 배열로 변환하는 메소드와 2번인 InputStream을 String으로 변환하는 메소드가 가장 많이 쓰일 것이다.\nIO 처리 시에는 특히나 byte 배열을 처리할 일이 많다. Base64 인코딩을 하거나 소켓을 사용할 때에도 byte 배열을 기준으로 사용한다.\n3번인 emptyInput() 메소드는 얼핏 보면 무가치 할 것 같지만 의외의 유용성이 높은데, InputStream을 매개변수로 주거나 반환할 때 null 대신 쓰이기 좋을 것이다.\n   표준 문자셋   java.nio.charset.StandardCharsets JavaDoc  잠깐 짚고 넘어갈 표준 문자셋은 JDK 1.7부터 존재한다. 실제로 1.7 이전에는 문자셋 설정을 스트링으로 받았었다.\n1 2  String str = new String(byteArray, \u0026#34;UTF-8\u0026#34;); String str = new String(byteArray, Charset.forName(\u0026#34;UTF-8\u0026#34;));   이런 식으로 처리 했어야 했는데, 문제는 String 타입의 매개변수의 문자셋 코드가 잘못 입력했을 때이다. 그땐 UnsupportEncodingException으로 인해 프로그램이 중단된다. IOException의 자식 클래스여서 더 심각했다.\n그래서 표준 문자셋 객체 상수를 StandardCharsets 클래스에 정의하였다. 따라서 이제는 다음과 같이 안전하게 처리할 수 있다.\n1  String str = new String(byteArray, StandardCharsets.UTF_8);   만약, EUC-KR을 쓰고 싶다면? Exception을 처리해야 할 위험성이 계속 존재하지만 다음과 같은 방법으로 해야 한다.\n1  String str = new String(byteArray, Charset.forName(\u0026#34;EUC-KR\u0026#34;));      FileCopyUtils 유틸 클래스   Spring Framework FileCopyUtils JavaDoc  위의 StreamUtils 유틸 클래스는 버전 3.2.2 부터 생긴 반면, FileCopyUtils는 초기 버전에도 존재했다. 유틸 클래스 이름 그대로 파일을 복사하는 정적 메소드가 담겨있다. 자세한 내용은 JavaDoc을 참조 바란다.\n물론 JDK 1.7이상이라면 java.nio.file.Files 클래스를 사용하는 것이 더 좋다. 더 편리하고 다양한 유틸리티 정적 메소드들이 존재한다.\n   Resource 인터페이스와 구현체   Spring Framework Manual Spring Framework Resource JavaDoc  Resource는 인터페이스다. 그냥 사용할 수는 없고 다음과 같은 구현된 클래스가 존재한다.\n UrlResource ClassPathResource FileSystemResource PathResource ServletContextResource InputStreamResource ByteArrayResource  jar과 같이 묶이는 파일은 ClassPathResource를 이용하고, 일반적인 파일을 읽어올 땐 FileSystemResource 를 사용한다. 따라서 리소스에 텍스트 파일을 저장하고 읽어오고 싶을 땐 다음과 같은 방법을 사용할 수 있다.\n1 2 3 4 5 6 7  import org.springframework.core.io.Resource; import org.springframework.core.io.ClassPathResource; import org.springframework.util.StreamUtils; import java.nio.charset.StandardCharsets; ... Resource resource = new ClassPathResource(\u0026#34;load.txt\u0026#34;); String loaded = StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);   간편한 방법이지만 이건 경로를 직접 하드코딩 해야하는 단점도 존재한다. 스프링 프레임워크를 쓰는 이유가 강력한 Dependency Injection(의존 주입)에 의한 IoC 컨테이너를 사용 하기 위함도 있을 것이다.\n특히 스프링 부트를 사용한다면 application.properties (또는 yaml)의 존재를 알 것이다. properties와 @Value 애노테이션의 조합으로 DI를 이용해 불러 올 수도 있다.\nload.resource=classpath:load.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Component public class LoadResource { private final String loaded; @Autowired public LoadResource(@Value(\u0026#34;${load.resource}\u0026#34;) Resource loaded) { this.loaded = StreamUtils.copyToStream(loaded.getInputStream(), StandardCharsets.UTF_8); } public String getLoaded() { return loaded; } }   또는 이와 같이 Value 애노테이션에 하드코딩하여 넣을 수도 있다.\n1  @Value(\u0026#34;classpath:load.txt\u0026#34;)      마치며  물론 스프링 프레임워크를 사용하지 않아도, Java를 사용한다면 아래와 같은 친숙한 라이브러리들이 있다.\n  commons-io\n1  String str = IOUtils.toString(inputStream, StandardCharsets.UTF_8);     Guava\n InputStream을 String으로 변환.  1 2 3 4 5 6 7  ByteSource source = new ByteSource() { @Override public InputStream openStream() throws IOException { return inputStream; } }; String str = source.asCharSource(StandardCharsets.UTF_8).read();    classpath 내 파일을 읽어 String으로 가져오기.  1  String str = Resources.toString(Resources.getResource(\u0026#34;load.txt\u0026#34;), StandardCharsets.UTF_8);     JDK 9 이상\n1  String str = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8);     Apache Commons와 Google Guava는 둘 다 많이 찾고 쓰는 자바 라이브러리 묶음들이다. IO부분은 commons-io 라이브러리가 간편하고 강력한 편이지만 개인적으론 Guava가 라이브러리 구성이 좋아 선호한다.\n최근 JDK 버전들은 유틸 클래스 등도 강화가 많이 되어, 특정 라이브러리가 없어도 개발이 많이 편해졌다. 그래도 스프링 프레임워크의 강력한 기능과 엮어 사용하면 더욱 더 강력하고 객체지향적이게 사용할 수 있다.\n","date":"Oct 23","permalink":"https://hellomike.page/posts/2021/spring-utils-io-resources/","tags":["java","spring","io","utils","resources","streamutils","classpath"],"title":"스프링 프레임워크에서 StreamUtils, Resource를 이용해 파일 읽어오기"},{"categories":null,"contents":"   Hello, Mike!  안녕하세요. Mike입니다. 저는 Web 기술을 바탕으로 개발하는 회사의 사원입니다. 특히 Java, Spring의 백엔드와 Typescript, React.js의 프론트엔드 기반 기술을 다룹니다. 관계형 데이터베이스와 Kubernetes와 같은 컨테이너 가상화 기반 클라우드 기술들도 다룹니다.\n개인적으로는 먹는 것, 듣는 것, 읽는 것을 좋아합니다. 노래, 맛집, 소설들도 기회가 된다면 블로그에 쓸 수 있으면 좋겠습니다.\n   블로그 소개  개발을 처음 시작 할 때, 우리가 처음 쓰던 그 코드가 있습니다.\n1 2 3 4 5 6  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char** argv) { printf(\u0026#34;Hello, world!\u0026#34;); return 0; }   \u0026lsquo;데니스 리치\u0026rsquo;, \u0026lsquo;브라이언 W. 커니핸\u0026rsquo;의 The C Programming Language에서 시작된 \u0026lsquo;Hello, world!\u0026lsquo;는 이제는 프로그래밍을 공부한다면 한 번씩 콘솔에 띄어보는 경험을 합니다. 블로그 제목은 그것에서 영감을 받았습니다.\n이 블로그는 개발자로서 공부하며 배운 것들을 남기고자 시작합니다. 별 것 아닌 글일 수 있지만, 제 자신의 기억에 조금 더 남기고자 적는 블로그입니다.\n저는 현재는 웹을 기반으로 작업하는 개발자입니다. 일단 프론트엔드, 백엔드, 인프라, 데이터베이스를 주 종목으로 하고 있습니다. 물론 언젠간 다른 분야에서 일할 수도 있겠지만 시작점에서 몇년간은 웹 기반을 주 목적으로 글을 쓸 것입니다.\n이 블로그를 찾아주신 분들 모두 감사드리며, 특히 이 글을 보고 계신다면, 더욱 더 감사드립니다.\n   블로그 구성  이 블로그는 Hugo로 구성했으며, Github Actions를 이용하여 빌드 후, Github Pages에서 서비스 중입니다.\n블로그의 Favicon은 Emoji의 \u0026lsquo;👋\u0026rsquo;를 Noto Emoji의 형태를 사용하고 있습니다. Favicon 라이센스는 Noto Emoji의 Apache License 2.0을 따릅니다.\n블로그의 원 소스 레포지토리는 mike-kwak/blog에서 보실 수 있습니다.\n댓글은 Giscus를 사용하며, 블로그 소스 레포지토리의 Github Discussions와 연동되어 있습니다.\n블로그의 테마는 Hugo Tania를 사용하였으며, 제가 사용하기 위해 일부 커스텀한 결과물이 있습니다.\n   라이선스  mike-kwak/blog 내 문서를 제외한 내부 코드 들은 MIT 라이선스를 적용합니다.\n블로그의 글은 CC-BY 4.0를 적용합니다. 블로그 글 내에서 출처가 따로 없는 제가 작성한 예시 코드들은 Public Domain이므로 저작권을 굳이 표기 안하셔도 자유롭게 사용 가능합니다.\n","date":"Oct 23","permalink":"https://hellomike.page/about/","tags":null,"title":"소개"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://hellomike.page/articles/","tags":null,"title":"글 목록"}]